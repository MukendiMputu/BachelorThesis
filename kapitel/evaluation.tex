\chapter{Evaluation}\label{ch:eval}

This chapter presents the results of our thesis subject approach and describes the problems we encountered while developing the application. We will delve a little deeper into specific graph models from the TODO-App documentation and explain their desired outcomes in detail. We will also talk about our WebDoc application's limitations and overall effectiveness.

\section{Method selection}\label{sec:meth}

In this thesis, we have implemented a graphical language to allow non-programmers to use an automated method for developing end user documentation for Web applications.

The first challenge we encountered with our approach was to determine the complete list of Web elements necessary for automating the documentation generation process. Even though websites have an inherent uniqueness, they still are constructed with the same fundamental elements: structural elements like paragraphs or tables and interactable elements like input forms and buttons. We specified, therefore, those elements in one of the metalanguages of our graphical DSL, the Doc.mgl. The approach led to the next challenge, giving the developer a way to give semantic meaning to those model elements. We added, therefore, a String property named description that enabled documenting each node of the graph model. The subsequent step of generating the Markdown files would produce a detailed documentation page for that model.
Another challenge we faced was to produce a Selenium script in Java that, based on the same model sequence, would automate the Web browser and take screenshots of the indicated elements. Thus, we mapped each node element with a specific action implemented as a Java method. That allowed us to construct a Selenium script in the same generation process by collecting the methods mapped to the model node elements.


The fact that we used a graphical DSL to solve the problem makes our editor user-friendly. The developer can easily make model representations of the Web application and then generate documentation from them. Moreover, if we recall the similar approaches presented in section \ref{sec:relWork}, no programming knowledge is required to use the WebDoc. For instance, taking a deeper look at the login feature (cf. fig.~\ref{fig:loginSeq}), we created a model that starts by leading the WebDriver to the application landing page and logs in into the TODO-App using a Navigation node, Timer nodes that ensure that crucial Web elements appear before taking screenshots and an input form, which comprises two input fields for the username and password and a submit button. We implemented a feature to address and highlight all WebElements to make them visible on the screenshots. We also implemented the Comment node, which adds text as a caption to each screenshot in the Markdown file. The model has a Section node that acts as a syntactical delimiter and as a semantic section providing additional information. So, the effort to form such a model is small for a domain expert familiar with the Web application.

Additionally, the approach applied in this thesis efficiently produced a documentation website for the TODO-App, since the WebDoc allows one to create a documentation page without using additional resources. That is, from the concept to the finished documentation, the developer only needs to construct the diagram and, in another step, run the Selenium script.

\section{Setup}\label{sec:setup}

The WebDoc editor application is a \textsc{Cinco} editor based on Eclipse. Setting up the development environment is straightforward -- at least if a particular acquaintance with the Eclipse environment exists. Beforehand, a version of Java must be present on the system to run the application. Also, to automate a Web browser of choice, the corresponding Selenium WebDriver executable must be downloaded, and its path location must figure in the system's \lstinline{PATH} variable.

We have already taken care of the Selenium libraries by generating the pom.xml file containing the required dependencies, and the resulting application structures, as mentioned in previous chapters, follow the convention. So, the application needs no additional configurations.

After downloading and extracting the application package, it must be started just like a standard Eclipse IDE would typically be. Next, a splash screen presenting the application and indicating the progress of the launch process appears, and within a few seconds, the WebDoc IDE starts.

\section{Results}\label{sec:res}

Our goal to document the TODO-App introduced in section~\ref{sec:todoApp} was addressed by specifying a graphical DSL from two different metalanguages using the \textsc{Cinco} Meta Tooling Suite. One allowed us to design user activities using graphical representations of UI elements. Another allowed us to gather those activities into application functionalities and served as the generation starting point. Tailoring our graphical DSL to this end ensured the adequacy of the WebDoc to model and create end user documentation for Web applications.

As a result, we began by identifying and then modeling seven features of the TODO-App: the first is the login capability, which allows users to access the dashboard. Then there are the abilities to add and remove tasks from task lists and create and remove tasks from them. We also have the functionalities for adding and deleting a list owner, which allows a logged-in user to add and remove another user as co-owner of a tasks list. All of those features were then regrouped in the FeatureGraphModel and kept separated within featureContainers (see fig. \ref{fig:featGraph}). This separation allowed us to generate feature documentation independently. However, it also created the issue of the Selenium-Java program having to reset the Web application state after the automation process terminates. We could not address this issue by hard-coding the solution because each Web application has its navigational graph, hence different reset sequence paths. The documentation designer must deal with the application reset by modeling a sequence that does this.

Although we could document the TODO-App with all its features, the WebDoc still has limitations in some execution points:

The FeatureGraphModel acts as the entry point of the documentation model; herein, the user regroups all application features and starts the generation process. Nevertheless, it is possible to create two FeatureGraphModel files inside one project, breaking the idea of having a single generation entry point. We still have to remove this possibility by restricting the number of FeatureGraphModel files (.feat) the user can create to just one.

Furthermore, documenting a Web application that requires HTTP basic authentication, for example, is still not realizable with the model elements our graphical DSL offers (HTTP basic authentication or htaccess is a content password protection measure that occurs before even loading the complete website, and ask for credentials in a modal dialog.~\cite{htaccess}). On the Selenium FAQ ( Frequently Ask Questions)~\cite{SeleniumFAQ}, a proposed workaround is to provide the user credentials in the URL of the website like following \lstinline{http://username:password@example.com}. Even though we still can add documentation text for the reader about how to handle those floating windows before or after their appearance in our model, we still cannot pass such windows and continue with the execution of the Selenium script. Using CSS or HTML selectors to address Web elements in a modal is still a work in progress since they do not belong to the website's document tree.

Moreover, choosing a sequential execution for our generator made it challenging to perform specific Selenium actions outside the execution workflow. That is, highlighting a Web element just for the screenshot without executing that element's specific action is still not working as intended. We implemented, therefore, an additional node that takes the highlighting and unhighlighting capability of a Web element outside of the element itself. That way, elements can be highlighted for the screen capture and unhighlighted right after, returning the appearance of those elements to their previous state for subsequent script execution. 

Consequently, our editor application offered the capability to create a graphical model, which upon clicking the \textit{generate button}, triggers the creation of both the Java application and the VuePress project structure. Subsequently, the Selenium WebDriver takes the indicated screenshots and saves them within the VuePress project folders.