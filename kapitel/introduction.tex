% introduction.tex
\chapter{Introduction}\label{ch:intro}

One of the most challenging tasks in software development is developing a long-term strategy for creating, managing, and updating the documentation for the end users as the software product develops, adapts, or increases in complexity~\cite{ieee6081814}. The challenge lies in the fact that the development team tasked to document the software must do it manually by first selecting the information most valuable to the end users, structuring it, and then when required updating it. In other words, the developer must reproduce the steps or whole scenarios a potential end user would go through and document where useful information must be provided to reduce the time needed to understand the main functionality of the software. 

Completing this process once does not necessarily free the developer from the task, for it is a cycle that must be repeated every time an update is introduced, or a relevant part of the program has been changed. For a small static Web page, this might not sound dramatic, but considering complex applications developed by multiple teams, this task can raise the cost in time and resources as the information about the whole project must be collected for the design of the documentation~\cite{ieee5712775}. So, the problem is to find a way to automatically go through all those steps and generate parts of the documentation model extended with semantic description and later assemble those to generate complete documentation.

Software projects are bound by budget and deadline requirements. This leads to the fact that automation processes become essential where the reduction of the development time can be increased~\cite{despa2014comparative}. It is, therefore, of significant advantage for the developing team \textit{and} the end user that the generation of user documentation is modeled in such a way that it always reflects the most current development status of the software product~\cite{waits_et_al}. This thesis introduces the use of a graphical \gls{dsl} -- a programmatic language adapted to a specific domain problem~\cite{perez-et_al} -- as an alternative way of modeling end user documentation.

\section{Objectives}\label{sec:objectives}

This thesis proposes a solution for automatically generating end user documentation for Web applications by means of a graphical \gls*{dsl}, a similar approach to~\cite{bosselmann-et_al}. We developed an application for modeling different user action sequences in a Web application using the \textsc{Cinco} SCCE Meta Tooling Framework~\cite{Cinco} and for subsequently generating end user documentation in Markdown syntax. The \textsc{Cinco} framework is a generator-driven development environment for domain-specific graphical modeling tools. It is based on the Eclipse Modeling Framework and Graphiti Graphical Tooling Infrastructure but aims to hide much of their complexity and intricate \gls{api}\footnote{More information can be found at \url{https://cinco.scce.info/}}. For evaluation purposes, we document a task management Web application of our own. Nonetheless, the applied method can be extrapolated to any other Web application since the elementary building blocks of those applications are the same.

The project has a Maven nature, which allows us to manage the package dependencies and take advantage of its build life cycles for building and distributing the application\footnote{The code for the application can be found here \url{https://github.com/MukendiMputu/UserDocGenerator}}.

The Markdown-based documentation is supplemented with screenshots taken with the Web browser automation engine, which drives the Web application to replicate user actions. In addition to that, we serve the generated Markdown files containing references to the screenshots as a static site.

\section{Related Work}\label{sec:relWork}

Documenting a software application -- be it as a desktop application or a Web application -- has always been a daunting task for the developer. Nonetheless, it is a task many developers are neither enthusiastic nor motivated to do~\cite{kipyegen2013importance}. This raised the attention of many researchers on the topic, so that previous similar solutions had been proposed in the past:

\cite{descher_et-al} also proposed in 2015 the Ã‰crit Toolkit, a solution in which the Eclipse Rich Client Platform~\cite{eclipseRCP} application model is used to provide a semantic description of the model element. Those semantic descriptions were later aggregated to a documentation text complying with ISO/IEC 26514~\cite{descher_et-al}. The generation steps consisted of an application model with the semantic description being analyzed and converted into an EcritDocument model that was used as input for a Document Outputter, which produced \LaTeX or HTML code. Coding knowledge was necessary to be able to verify the produced documentation. The project is no longer under active development.

GuideAutomator~\cite{oliveira2016guideautomator} was proposed in 2016 as part of a bachelor's thesis. The approach was to provide Markdown files with short JavaScript chunks that determine how to capture each screencast~\cite{guidAutomatorGitHub}. This implied that preexisting Markdown files were required as input for the generator, which then executed the JavaScript code snippet using Selenium. This approach limited itself in a way that knowledge of the JavaScript programming language was required. The Markdown file had to manually be generated prior to the generator's execution, which did not support the rt the reusability of such Markdown file. According to the last GitHub commit, which goes back to September 2018, the project is no longer being actively developed.

In this thesis, we decided to keep the philosophy adopted by the developers of the \textsc{Cinco} framework. Our approach prioritizes the reusability and simplicity of our graphical language amongst the most important features we aimed to implement. Those features enable non-programmers to design graph models of the Web application they desire to document by arranging the graphical elements our language proposes to a logical sequence of actions. The editor takes care of the generation of the executable application code and all the documentation files necessary. Furthermore, we also assist the documentation designer in creating correct models by checking the syntactical correctness of the diagram at runtime.

\section{Outline}\label{sec:outline}

Chapter  presents the \textsc{Cinco} SCCE Meta Tooling Framework, in particular the two metalanguages (\glsentryfull{mgl} and \glsentryfull{msl}) that constitute the meta-specification (Section \ref{sec:MGL} and \ref{sec:MSL}) of our graphical domain-specific language. The chapter then rounds off with an outline of the Generator classes written in Xtend, a Java dialect that offers much flexibility and expressiveness in its syntax (Section \ref{sec:GEN}).\\The specifics of the generated modeling platform are described in chapter \ref{ch:CP}. Whereby Section \ref{sec:gDSL} explains the basic concepts of a graphical domain-specific language, then Sections \ref{sec:FeaGrahptModElem}, \ref{sec:DocGrahpModElem} and \ref{sec:GenProcess} relate about different modeling elements for configuring and designing the end user documentation. In chapter \ref{ch:eval} a in-depth explanation of the methodology is given. Beginning with the evaluation of the selected work method in Section \ref{sec:meth} followed by the system setups and the result of the approach taken in this thesis(Section \ref{sec:setup} and \ref{sec:res}). Lastly, chapter \ref{ch:epilogue} winds up with a discussion on the thesis and further improvements of the program.